<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>F1 Dash</title>
  <style>
*{box-sizing:border-box;-webkit-tap-highlight-color:rgba(0,0,0,0)}
html,body{margin:0;padding:0;height:100%;background:#0a0a0a;overscroll-behavior:none}
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:#fff;touch-action:none}
#game{display:block;width:100vw;height:100dvh}
#hud{position:fixed;top:env(safe-area-inset-top);left:0;right:0;display:flex;justify-content:space-between;padding:12px 16px;pointer-events:none}
#score{font-weight:800;font-size:24px;letter-spacing:.5px}
#best{opacity:.8;font-size:14px}
#touchHint{position:fixed;bottom:calc(env(safe-area-inset-bottom) + 18px);left:0;right:0;text-align:center;opacity:.75;font-size:14px}
  </style>
</head>
<body>
  <div id="hud">
    <div id="score">0</div>
    <div id="best">BEST: 0</div>
  </div>
  <canvas id="game"></canvas>
  <div id="touchHint">Tap left/right to steer â€¢ Double-tap = dash</div>

  <script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const scoreEl = document.getElementById("score");
  const bestEl = document.getElementById("best");
  const hintEl = document.getElementById("touchHint");
  let W = 0, H = 0, DPR = Math.max(1, window.devicePixelRatio || 1);

  // Track lane bounds
  const lanes = { left: 0, right: 0, width: 0 };

  function resize() {
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

    lanes.left = W*0.18;
    lanes.right = W*0.82;
    lanes.width = lanes.right - lanes.left;
  }
  window.addEventListener("resize", resize, {passive:true});
  resize();

  const state = {
    running: true,
    time: 0,
    score: 0,
    best: Number(localStorage.getItem("f1_best") || 0),
    player: { x: W/2, y: H*0.8, w: 18, h: 36, speed: 360, vx: 0, dash: 0 },
    rivals: [],
    spawnT: 0,
    pressedLeft: false,
    pressedRight: false,
    gameOver: false,
    lastTap: 0,
    dashCooldown: 0
  };
  bestEl.textContent = "BEST: " + state.best;

  // Input
  function onTouchStart(e){
    e.preventDefault();
    hintEl.style.display = "none";
    const now = performance.now();
    if (now - state.lastTap < 260) tryDash();
    state.lastTap = now;
    for (const t of e.changedTouches){
      (t.clientX < W/2) ? state.pressedLeft = true : state.pressedRight = true;
    }
  }
  function onTouchEnd(e){
    e.preventDefault();
    for (const t of e.changedTouches){
      (t.clientX < W/2) ? state.pressedLeft = false : state.pressedRight = false;
    }
  }
  function onMouseDown(e){
    hintEl.style.display = "none";
    if (performance.now() - state.lastTap < 260) tryDash();
    state.lastTap = performance.now();
    (e.clientX < W/2) ? state.pressedLeft = true : state.pressedRight = true;
  }
  function onMouseUp(){ state.pressedLeft = state.pressedRight = false; }

  canvas.addEventListener("touchstart", onTouchStart, {passive:false});
  canvas.addEventListener("touchend", onTouchEnd, {passive:false});
  canvas.addEventListener("mousedown", onMouseDown);
  window.addEventListener("mouseup", onMouseUp);

  function tryRestart(e){
    if(!state.gameOver) return;
    e.preventDefault();
    reset();
  }
  canvas.addEventListener("touchstart", tryRestart, {passive:false});
  canvas.addEventListener("mousedown", tryRestart);

  function tryDash(){
    if (performance.now() < state.dashCooldown) return;
    state.player.dash = 1.0;           // seconds of tighter steering
    state.dashCooldown = performance.now() + 2200;
    if (navigator.vibrate) navigator.vibrate([12,50,12]);
  }

  function reset(){
    state.rivals.length = 0;
    state.time = 0;
    state.score = 0;
    state.player.x = W/2;
    state.player.y = H*0.8;
    state.player.dash = 0;
    state.gameOver = false;
    state.running = true;
  }

  // Helpers
  const rand=(a,b)=>Math.random()*(b-a)+a;
  const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
  const lerp=(a,b,t)=>a+(b-a)*t;

  function spawnRival(){
    const lanePad = lanes.width * 0.08;
    const w = rand(24,34);
    const x = rand(lanes.left + lanePad, lanes.right - lanePad - w);
    const speed = lerp(220, 520, clamp(state.time / 60, 0, 1));
    const hue = 0 | ((state.time*20 + Math.random()*120) % 360);
    state.rivals.push({x, y:-40, w, h:w*1.6, vy:speed, color:`hsl(${hue} 85% 55%)`});
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  function update(dt){
    if (!state.running) return;
    state.time += dt;

    const steerBoost = state.player.dash > 0 ? 1.9 : 1.0;
    state.player.vx = (state.pressedLeft ? -1 : 0) + (state.pressedRight ? 1 : 0);
    state.player.x += state.player.vx * state.player.speed * steerBoost * dt;
    const half = state.player.w * 0.5;
    state.player.x = clamp(state.player.x, lanes.left + half, lanes.right - half);

    if (state.player.dash > 0){
      state.player.dash -= dt;
      if (state.player.dash < 0) state.player.dash = 0;
    }

    // Spawn + move rivals
    state.spawnT -= dt;
    const spawnInterval = clamp(0.9 - state.time*0.006, 0.28, 0.9);
    if (state.spawnT <= 0){ spawnRival(); state.spawnT = spawnInterval; }
    for (const r of state.rivals) r.y += r.vy * dt;

    // Score + cleanup
    while (state.rivals.length && state.rivals[0].y - state.rivals[0].h > H){
      state.rivals.shift();
      state.score++;
      scoreEl.textContent = state.score;
      if (state.score > state.best){
        state.best = state.score;
        bestEl.textContent = "BEST: " + state.best;
        localStorage.setItem("f1_best", String(state.best));
      }
    }

    // Collision
    for (const r of state.rivals){
      if (rectRect(state.player.x - state.player.w/2, state.player.y - state.player.h/2, state.player.w, state.player.h,
                   r.x, r.y, r.w, r.h)){
        gameOver(); break;
      }
    }
  }

  function rectRect(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  let flash = 0;
  function gameOver(){
    state.running = false;
    state.gameOver = true;
    if (navigator.vibrate) navigator.vibrate(60);
    flash = 1;
  }

  function render(){
    // Asphalt
    ctx.fillStyle = "#0f1114";
    ctx.fillRect(0,0,W,H);

    // Grass
    ctx.fillStyle = "#0b3d1a";
    ctx.fillRect(0,0,lanes.left,H);
    ctx.fillRect(lanes.right,0,W-lanes.right,H);

    // Kerbs
    const kerbW = 10, kerbH = 28, gap = 12, offset = (performance.now()/20)%(kerbH*2 + gap*2);
    for (let y = -offset; y < H + kerbH; y += kerbH*2 + gap*2){
      drawKerb(lanes.left-kerbW, y, kerbW, kerbH);
      drawKerb(lanes.right, y+kerbH+gap, kerbW, kerbH);
    }

    // Center dashed line
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 3;
    ctx.setLineDash([14, 18]);
    ctx.beginPath();
    ctx.moveTo((lanes.left+lanes.right)/2, 0); ctx.lineTo((lanes.left+lanes.right)/2, H);
    ctx.stroke();
    ctx.restore();

    // Rivals
    for (const r of state.rivals) drawCar(r.x, r.y, r.w, r.h, r.color, 0);

    // Player
    drawCar(state.player.x, state.player.y, state.player.w, state.player.h, "#00e1ff", 1, state.player.dash);

    if (state.gameOver){
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "700 28px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif";
      ctx.fillText("Crash!", W/2, H/2 - 8);
      ctx.font = "400 16px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif";
      ctx.fillText("Tap to race again", W/2, H/2 + 18);
    }

    if (flash > 0){
      ctx.fillStyle = `rgba(255,255,255,${flash})`;
      ctx.fillRect(0,0,W,H);
      flash = Math.max(0, flash - 0.1);
    }
  }

  function drawKerb(x, y, w, h){
    ctx.fillStyle = "#d81d1d"; ctx.fillRect(x, y, w, h);
    ctx.fillStyle = "#ededed"; ctx.fillRect(x, y + h, w, h);
  }

  function drawCar(cx, cy, w, h, color, isPlayer, dash=0){
    const x = cx - w/2, y = cy - h/2;
    // Shadow
    ctx.save(); ctx.globalAlpha = 0.25; ctx.fillStyle = "#000"; ctx.fillRect(x+2, y+4, w, h); ctx.restore();
    // Body
    ctx.fillStyle = color; ctx.fillRect(x, y+h*0.1, w, h*0.8);
    // Nose
    ctx.beginPath(); ctx.moveTo(cx, y); ctx.lineTo(x, y+h*0.2); ctx.lineTo(x+w, y+h*0.2); ctx.closePath(); ctx.fillStyle = color; ctx.fill();
    // Rear wing
    ctx.fillStyle = "#111"; ctx.fillRect(x - w*0.15, y + h*0.85, w*1.3, h*0.1);
    // Tires
    ctx.fillStyle = "#111"; const th = h*0.22, tw = w*0.25;
    ctx.fillRect(x - tw, y + h*0.15, tw, th);
    ctx.fillRect(x - tw, y + h*0.65, tw, th);
    ctx.fillRect(x + w, y + h*0.15, tw, th);
    ctx.fillRect(x + w, y + h*0.65, tw, th);
    // Halo/driver
    ctx.fillStyle = "#222a"; ctx.fillRect(cx - w*0.2, y + h*0.4, w*0.4, h*0.12);
    ctx.beginPath(); ctx.arc(cx, y + h*0.42, w*0.16, 0, Math.PI*2); ctx.fillStyle = "#111"; ctx.fill();
    // Dash outline
    if (isPlayer && dash > 0){
      const a = 0.35 + 0.35 * Math.sin(performance.now()/90);
      ctx.save(); ctx.globalAlpha = a; ctx.lineWidth = 3; ctx.strokeStyle = color;
      ctx.strokeRect(x-3, y-3, w+6, h+6); ctx.restore();
    }
  }

  requestAnimationFrame(loop);
})();
  </script>
</body>
</html>
